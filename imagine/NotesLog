      Copyright (c)  2005-2006  AtKaaZ.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.2
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
      Texts.  A copy of the license is included in the section entitled "GNU
      Free Documentation License".

Legend:
	~ means NOTE
	LU means last update on ... date

=demlinks-0.0.23
LU: 29 September 2006

~ if what I imagine about demlinks is going to happen then this might be my response to DRM; in other words demlinks should be the opposite of DRM; it should give the freedom that anybody should imagine when they think about software; the freedom in coding the ability to (practicly be able to) change anypart of the software requiring little background knowledge from the user, and since all elements are connected it would be really neat to troubleshoot anything without having to use external information ie. manuals, docs, search engines; just the program itself serves as both binary and source+docs; just imagine the amount of learning resulting from this.

~ this may be just apparent but seems to me that berkeley db cannot return the
last datum of a give dup key with DB_LAST; the latter refers to the last item
of the database thus the key param to get()[cursor] is ignored!

~ bewarned that DB_XXX flags passed to ie. Db->put() or Dbc->put() are not
binary ie. DB_CURRENT=7 and DB_KEYFIRST=15 thus if you're expecting the former
with (DB_CURRENT == (DB_CURRENT & flags)) you'll get it even if it's only the
latter; ok, if this wasn't clear enough former=DB_CURRENT; latter=DB_KEYFIRST

~ so far there's no sensible way to view the contents of the database(s);
planning on doing that with 3D

~ we'll have to fix stuff when situations like throwing while db is open will
have to close it before throwin from main() otherwise who knows what's
happening with the data; so far we're recreating the dbase on each run.

~ for some weird reason, 800x600 and 1024x768 resolutions don't work with
nvidiafb (console framebuffer) thus we use 1024x766

~ for some unknown reason while running ./1 from within 'mc'(Midnight Commander 4.6.1)
allegro fails to init keyboard at line 348 in file timedkeys.cpp; so exit 'mc'
this with framebuffer in mind(not in X.org) also note declare -x SHLVL="2" from
within 'mc' and the fact that ./1 is running the executable with root rights(sudo)
also /usr/lib/mc/cons.saver has suid root (chmod u+s cons.saver)

~ running on console with nvidiafb framebuffer using allegro 4.3.1 from svn
7475
~ kGroup or kSubGroup are called Node(s); A node can be paradoxally any or
both of kGroup and kSubGroup, depending on the point of view;

~ yes, graphics mode, doesn't work in console (at least not in ubuntu afaik),
could work on slackware with svgalib.

~ we won't try to make a unit standalone (ie. timedkeys.cpp: we'll make
MoveFirstFromBuffer() to create elemens using dmlenv.cpp therefore the former
will depend on the latter so timedkey.cpp is not standalone); we won't care
about making standalone units anymore: they'll be irrelevant considering
demlinks can do what they do better;

=demlinks-0.0.22
LU: 10 August 2006

~ alot of inconsistencies projected to exist (ie. outdated comments)

~ ./2 ; the root expression doesn't get assigned neither as left nor as right
operand - this was/is the intended behaviour

~ there are two patches (still not present in svn 7457) that fix the issue
with keeping a key pressed (in X) while in our program causes random release
then keypress again events (allegro's way of getting inputs from X)

~ just a note: does compile with alleg.sf.net from svn revision 7392

~ only the first cammera is accessible (since some time now)

=demlinks-0.0.5
* LU: 09 August 2005.
* TODO: transform any kind of input into generic input, then generic input into actions; an action means: on activation execute a function, on deactivation execute a(nother) function, if no deactivation function then the action gets deactivated after one (func) execution (while active). Like this:
        key   -\
         mouse-->-----> generic input ----> actions
        serial-/
 this means that take any one of key,mouse or serial(don't mix), many or one inputs of that type will be converted into one input of 'generic input' type; then take many or one inputs of 'generic input' type and they will be converted into one action; an actions consists of one procedure(function) that gets executed. Any of those five items are serial meaning they push items into a FIFO buffer. The buffer may be read at any time by executing software even if the necessary combinations aren't complete yet to fulfill the next stage(ie. incomplete key combination, thus generic input isn't triggered this time). Action can be of type: once OR continous. Once type, gets executed only once. Continous type, gets executed until the deactivation combination is received(that is, some generic input triggers the deactivate part of this action). This type of actions only trigger active if they previously were inactive, likewise only trigger deactivation if they were previously active. Actions may be triggered by user in any part of the program, also they can be disabled to stop checking if they occur but keeping their previous state. Actions are taken one at once and executed, thus u cannot cumulate actions to sum-up to another action, use generic input type cumulation instead.

