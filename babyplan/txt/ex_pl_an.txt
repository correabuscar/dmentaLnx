# explanations/plan (c) AtKaaZ 04 march 2005
#
# <unique string recognized internaly by the exe> = <atomID>

filename = 1410 # acatom to word filename, acatom to words describing fname
directory = 1411

#all referers are atoms
#referers can be of two types: atom referer & group referer
# they're both atoms but one type refers to another atom and the other refers
# to another group
#referer is also called clone
# so atom referer = atom clone
# group referer = group clone
#and since referers are atoms:
# atom clone atom=the atom which is a referer to another antom
# group clone atom=the atom which is a referer to another group
#groups are chains, atoms if not single are perhaps part of a chain
# in order for a group referer to refer to a chain that chain must have one
# unique id, that's the groupID, actually it is the group, but the group is
# the chain.

#for starters we'll do some nice example program that will use dmental links
# to store a directory tree with text files inside it.
#The basix for this are the following:
# 1. the .exe must identify several atoms internaly, namely the filename, 
#	directory, size and contents. Example. the atomID with ID=300 will be
#	an acatom which points to the group containing the word "filename";
#	also this atom will be refered first in a group to signal to the .exe
#	that the group is identifying the filename, size, and contents of the
#	formerly brought file from outside world (nowadays filesystems)
#so this group could be like this:
#	1st atom points to atomID=300 just so the .exe can identify real file
#	names and words from their contents
#	2nd atom points to the atom which refers to the group containing the
#		word/words which make the filename of the former file.
#	3rd atom points to the atomID=400(contents) same, the .exe can identify
#	that the next 4th atom point to the group containing a big chain of 
#	atoms each pointing to a word, which group make the contents of the 
#	file.
#	4th atom points to the group which comprises the contents of the file
#so when the .exe axexes atomID=300 searching for a specified filename asked
# by the user (say "mumu.reg") it goes thru the list of all which refer to 
# atomID=300 and checks to see if they are a part of a group which contains
# 4 atoms (convention) and first atom is this which points to atomID=300
# if so, then we check atomID with order #2 from the group to see what's the
# text it points to, if it's "mumu.reg" then we got our file, if not, check 
# next item(atom) from the list of thos which refer to atomID=300.
#however, if there's such a file with contents which are 4 atoms long, and
# first atom points to the word filename, obv. the .exe wouldn't point to
# atomID=300 , but would point it to the word filename. Remember that 
# atomID=300 is an intermediar between the atom from the group and the word
# filename which is perhaps a group. 
#if we would want to find all the contents which contain the word filename,
# we'd go to the word filename(the group) which is uniq, and from there we'd
# check if atoms from the groups, which are considered to be `contents` of
# files, point to this word, therefore we won't get to our atomID=300
#it's really a matter of conventions which the .exe makes and respects to find
#wtw it wants within these dmental links ;;)
#----------------
#some generic shit, aka draft:
dmentalix:: class must provide funx like these:
    ::newelemental(basic_element thenewshit)
        *attempts to add a new eatom to the dmentalix :) if eatom's basic_elem already exists then its ID is returned, otherwise the new eatom is created and its ID is returned
        *returns 0 if an error occured,  or eatomID if some success
            _dmlerr_ variable could be _already_exist OR _newone to sig what has been done, if return was 0. OR if ret >0 _dmlerr_ is left unchanged from prev err.
    
